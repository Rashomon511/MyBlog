<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | 二求</title>
    <meta name="description" content="求真、求知">
    <link rel="icon" href="/logo.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.815e519c.css" as="style"><link rel="preload" href="/assets/js/app.20d1c662.js" as="script"><link rel="preload" href="/assets/js/2.b4f839d5.js" as="script"><link rel="preload" href="/assets/js/186.9e3fd258.js" as="script"><link rel="prefetch" href="/assets/js/10.4b2753e5.js"><link rel="prefetch" href="/assets/js/100.6ea2b2d8.js"><link rel="prefetch" href="/assets/js/101.00e2eacb.js"><link rel="prefetch" href="/assets/js/102.e13c214e.js"><link rel="prefetch" href="/assets/js/103.49cb7d56.js"><link rel="prefetch" href="/assets/js/104.b8008d28.js"><link rel="prefetch" href="/assets/js/105.2c405ca8.js"><link rel="prefetch" href="/assets/js/106.16c84672.js"><link rel="prefetch" href="/assets/js/107.b2add451.js"><link rel="prefetch" href="/assets/js/108.69ac9e18.js"><link rel="prefetch" href="/assets/js/109.a1732911.js"><link rel="prefetch" href="/assets/js/11.a2b16cf6.js"><link rel="prefetch" href="/assets/js/110.dc63d4ed.js"><link rel="prefetch" href="/assets/js/111.bc2dcfe0.js"><link rel="prefetch" href="/assets/js/112.94e62460.js"><link rel="prefetch" href="/assets/js/113.a50cc70e.js"><link rel="prefetch" href="/assets/js/114.b01cf432.js"><link rel="prefetch" href="/assets/js/115.3f92169e.js"><link rel="prefetch" href="/assets/js/116.126c49f6.js"><link rel="prefetch" href="/assets/js/117.0843796a.js"><link rel="prefetch" href="/assets/js/118.05d6260d.js"><link rel="prefetch" href="/assets/js/119.234d8d8d.js"><link rel="prefetch" href="/assets/js/12.23924584.js"><link rel="prefetch" href="/assets/js/120.53e9a10a.js"><link rel="prefetch" href="/assets/js/121.52a89779.js"><link rel="prefetch" href="/assets/js/122.894f0591.js"><link rel="prefetch" href="/assets/js/123.f77ec8f0.js"><link rel="prefetch" href="/assets/js/124.6170a51f.js"><link rel="prefetch" href="/assets/js/125.7696a287.js"><link rel="prefetch" href="/assets/js/126.963556bd.js"><link rel="prefetch" href="/assets/js/127.b4d691ba.js"><link rel="prefetch" href="/assets/js/128.36a80de9.js"><link rel="prefetch" href="/assets/js/129.454bde27.js"><link rel="prefetch" href="/assets/js/13.33f0b928.js"><link rel="prefetch" href="/assets/js/130.24a138ea.js"><link rel="prefetch" href="/assets/js/131.95f4480a.js"><link rel="prefetch" href="/assets/js/132.bd667c3f.js"><link rel="prefetch" href="/assets/js/133.eed300fd.js"><link rel="prefetch" href="/assets/js/134.60264d3c.js"><link rel="prefetch" href="/assets/js/135.5ea5838a.js"><link rel="prefetch" href="/assets/js/136.ff69842e.js"><link rel="prefetch" href="/assets/js/137.320f8dcf.js"><link rel="prefetch" href="/assets/js/138.1a30da61.js"><link rel="prefetch" href="/assets/js/139.0dbbacb0.js"><link rel="prefetch" href="/assets/js/14.a62efb88.js"><link rel="prefetch" href="/assets/js/140.b792f660.js"><link rel="prefetch" href="/assets/js/141.93bcadad.js"><link rel="prefetch" href="/assets/js/142.2505a9a7.js"><link rel="prefetch" href="/assets/js/143.748f76b7.js"><link rel="prefetch" href="/assets/js/144.3da50b8b.js"><link rel="prefetch" href="/assets/js/145.67d8155b.js"><link rel="prefetch" href="/assets/js/146.7e9df944.js"><link rel="prefetch" href="/assets/js/147.7daaf6b9.js"><link rel="prefetch" href="/assets/js/148.2b5b397b.js"><link rel="prefetch" href="/assets/js/149.7f398992.js"><link rel="prefetch" href="/assets/js/15.6ce785a0.js"><link rel="prefetch" href="/assets/js/150.8885ab95.js"><link rel="prefetch" href="/assets/js/151.ea9ca1a9.js"><link rel="prefetch" href="/assets/js/152.485d6c6c.js"><link rel="prefetch" href="/assets/js/153.eec718b7.js"><link rel="prefetch" href="/assets/js/154.70c20909.js"><link rel="prefetch" href="/assets/js/155.7edd7c7c.js"><link rel="prefetch" href="/assets/js/156.f2cc5f4b.js"><link rel="prefetch" href="/assets/js/157.5970fd48.js"><link rel="prefetch" href="/assets/js/158.3a4f7438.js"><link rel="prefetch" href="/assets/js/159.93f0b92b.js"><link rel="prefetch" href="/assets/js/16.e4f5874e.js"><link rel="prefetch" href="/assets/js/160.b9954e58.js"><link rel="prefetch" href="/assets/js/161.17cddcec.js"><link rel="prefetch" href="/assets/js/162.7b6de57b.js"><link rel="prefetch" href="/assets/js/163.fe8abeee.js"><link rel="prefetch" href="/assets/js/164.ed9634ec.js"><link rel="prefetch" href="/assets/js/165.12243b8d.js"><link rel="prefetch" href="/assets/js/166.d917647e.js"><link rel="prefetch" href="/assets/js/167.ffb2e689.js"><link rel="prefetch" href="/assets/js/168.a40332b7.js"><link rel="prefetch" href="/assets/js/169.66f38c1f.js"><link rel="prefetch" href="/assets/js/17.6ba5fdb5.js"><link rel="prefetch" href="/assets/js/170.16a5bb9d.js"><link rel="prefetch" href="/assets/js/171.6e67fc96.js"><link rel="prefetch" href="/assets/js/172.5c219ca5.js"><link rel="prefetch" href="/assets/js/173.3c2c09de.js"><link rel="prefetch" href="/assets/js/174.37ce9495.js"><link rel="prefetch" href="/assets/js/175.609286aa.js"><link rel="prefetch" href="/assets/js/176.c00ba532.js"><link rel="prefetch" href="/assets/js/177.a0b40180.js"><link rel="prefetch" href="/assets/js/178.6f419210.js"><link rel="prefetch" href="/assets/js/179.27160538.js"><link rel="prefetch" href="/assets/js/18.cfb9b423.js"><link rel="prefetch" href="/assets/js/180.f6123932.js"><link rel="prefetch" href="/assets/js/181.75f6df0e.js"><link rel="prefetch" href="/assets/js/182.7223a29a.js"><link rel="prefetch" href="/assets/js/183.4f1ddc09.js"><link rel="prefetch" href="/assets/js/184.06d242d5.js"><link rel="prefetch" href="/assets/js/185.cf28a5f7.js"><link rel="prefetch" href="/assets/js/187.32c183a2.js"><link rel="prefetch" href="/assets/js/188.2ae96b7a.js"><link rel="prefetch" href="/assets/js/189.54986241.js"><link rel="prefetch" href="/assets/js/19.edba6687.js"><link rel="prefetch" href="/assets/js/190.83b8206e.js"><link rel="prefetch" href="/assets/js/191.4b65c41b.js"><link rel="prefetch" href="/assets/js/192.5e75e003.js"><link rel="prefetch" href="/assets/js/193.ac72038d.js"><link rel="prefetch" href="/assets/js/194.b1ca1dc7.js"><link rel="prefetch" href="/assets/js/195.e7f22a19.js"><link rel="prefetch" href="/assets/js/196.292b3b97.js"><link rel="prefetch" href="/assets/js/197.9e1ea61c.js"><link rel="prefetch" href="/assets/js/198.801f7baf.js"><link rel="prefetch" href="/assets/js/199.2a0d6aaf.js"><link rel="prefetch" href="/assets/js/20.bfb012f9.js"><link rel="prefetch" href="/assets/js/200.ff819d2c.js"><link rel="prefetch" href="/assets/js/201.de0f6812.js"><link rel="prefetch" href="/assets/js/202.14ad6027.js"><link rel="prefetch" href="/assets/js/203.6857eaaf.js"><link rel="prefetch" href="/assets/js/204.3fe93b37.js"><link rel="prefetch" href="/assets/js/205.841fd0c9.js"><link rel="prefetch" href="/assets/js/206.6d659de1.js"><link rel="prefetch" href="/assets/js/207.c7c7edcd.js"><link rel="prefetch" href="/assets/js/208.fccd3973.js"><link rel="prefetch" href="/assets/js/209.c80d2e49.js"><link rel="prefetch" href="/assets/js/21.28b6a89b.js"><link rel="prefetch" href="/assets/js/210.1f1ba071.js"><link rel="prefetch" href="/assets/js/211.5a4b3c63.js"><link rel="prefetch" href="/assets/js/212.dc41ada3.js"><link rel="prefetch" href="/assets/js/213.49bce47c.js"><link rel="prefetch" href="/assets/js/214.2c370a41.js"><link rel="prefetch" href="/assets/js/215.1acaa667.js"><link rel="prefetch" href="/assets/js/216.ab042c62.js"><link rel="prefetch" href="/assets/js/22.e7d108d7.js"><link rel="prefetch" href="/assets/js/23.05563d47.js"><link rel="prefetch" href="/assets/js/24.7d424a59.js"><link rel="prefetch" href="/assets/js/25.fe3e6042.js"><link rel="prefetch" href="/assets/js/26.ecabc390.js"><link rel="prefetch" href="/assets/js/27.8021120a.js"><link rel="prefetch" href="/assets/js/28.fad4a91c.js"><link rel="prefetch" href="/assets/js/29.a1461cde.js"><link rel="prefetch" href="/assets/js/3.2df19221.js"><link rel="prefetch" href="/assets/js/30.970f53ff.js"><link rel="prefetch" href="/assets/js/31.fcf6cdf0.js"><link rel="prefetch" href="/assets/js/32.ad5ae882.js"><link rel="prefetch" href="/assets/js/33.dee4c928.js"><link rel="prefetch" href="/assets/js/34.73f33019.js"><link rel="prefetch" href="/assets/js/35.f10ee14e.js"><link rel="prefetch" href="/assets/js/36.c7628b0f.js"><link rel="prefetch" href="/assets/js/37.00923b69.js"><link rel="prefetch" href="/assets/js/38.d07fdae4.js"><link rel="prefetch" href="/assets/js/39.0ca52625.js"><link rel="prefetch" href="/assets/js/4.b6bebc07.js"><link rel="prefetch" href="/assets/js/40.772fb06a.js"><link rel="prefetch" href="/assets/js/41.45638d70.js"><link rel="prefetch" href="/assets/js/42.ffd85a55.js"><link rel="prefetch" href="/assets/js/43.42ea67a0.js"><link rel="prefetch" href="/assets/js/44.889f31eb.js"><link rel="prefetch" href="/assets/js/45.b444a8db.js"><link rel="prefetch" href="/assets/js/46.7e569fd7.js"><link rel="prefetch" href="/assets/js/47.ebac65f7.js"><link rel="prefetch" href="/assets/js/48.b84f27e7.js"><link rel="prefetch" href="/assets/js/49.5aa3f020.js"><link rel="prefetch" href="/assets/js/5.35065344.js"><link rel="prefetch" href="/assets/js/50.195d283a.js"><link rel="prefetch" href="/assets/js/51.d1eac07d.js"><link rel="prefetch" href="/assets/js/52.473c9c38.js"><link rel="prefetch" href="/assets/js/53.e4ae8236.js"><link rel="prefetch" href="/assets/js/54.f7e5a365.js"><link rel="prefetch" href="/assets/js/55.9189ebe5.js"><link rel="prefetch" href="/assets/js/56.212e1e0e.js"><link rel="prefetch" href="/assets/js/57.b7f502fd.js"><link rel="prefetch" href="/assets/js/58.39b98db3.js"><link rel="prefetch" href="/assets/js/59.82926a97.js"><link rel="prefetch" href="/assets/js/6.bd3f0f03.js"><link rel="prefetch" href="/assets/js/60.de7da7a6.js"><link rel="prefetch" href="/assets/js/61.0c39d949.js"><link rel="prefetch" href="/assets/js/62.6c01915c.js"><link rel="prefetch" href="/assets/js/63.915e4daf.js"><link rel="prefetch" href="/assets/js/64.c9b1ce31.js"><link rel="prefetch" href="/assets/js/65.e1c12df5.js"><link rel="prefetch" href="/assets/js/66.dca36839.js"><link rel="prefetch" href="/assets/js/67.525516a0.js"><link rel="prefetch" href="/assets/js/68.a1889e60.js"><link rel="prefetch" href="/assets/js/69.f899de9c.js"><link rel="prefetch" href="/assets/js/7.695ed75f.js"><link rel="prefetch" href="/assets/js/70.8fa50ea8.js"><link rel="prefetch" href="/assets/js/71.301c2686.js"><link rel="prefetch" href="/assets/js/72.e622d49b.js"><link rel="prefetch" href="/assets/js/73.e2b8a185.js"><link rel="prefetch" href="/assets/js/74.70c3e0c9.js"><link rel="prefetch" href="/assets/js/75.046236db.js"><link rel="prefetch" href="/assets/js/76.6f7e5956.js"><link rel="prefetch" href="/assets/js/77.f53aae34.js"><link rel="prefetch" href="/assets/js/78.124dca95.js"><link rel="prefetch" href="/assets/js/79.315c2ccb.js"><link rel="prefetch" href="/assets/js/8.bb75838a.js"><link rel="prefetch" href="/assets/js/80.6e4e5bd0.js"><link rel="prefetch" href="/assets/js/81.18926d88.js"><link rel="prefetch" href="/assets/js/82.102e702d.js"><link rel="prefetch" href="/assets/js/83.e210c358.js"><link rel="prefetch" href="/assets/js/84.7357d4dd.js"><link rel="prefetch" href="/assets/js/85.a1397cdc.js"><link rel="prefetch" href="/assets/js/86.7ae61907.js"><link rel="prefetch" href="/assets/js/87.1e4f1874.js"><link rel="prefetch" href="/assets/js/88.510f0be4.js"><link rel="prefetch" href="/assets/js/89.23a2c147.js"><link rel="prefetch" href="/assets/js/9.06b021a0.js"><link rel="prefetch" href="/assets/js/90.9d98332b.js"><link rel="prefetch" href="/assets/js/91.fc447e65.js"><link rel="prefetch" href="/assets/js/92.7d622748.js"><link rel="prefetch" href="/assets/js/93.f929d332.js"><link rel="prefetch" href="/assets/js/94.87a89da0.js"><link rel="prefetch" href="/assets/js/95.6f5e7aaf.js"><link rel="prefetch" href="/assets/js/96.37159420.js"><link rel="prefetch" href="/assets/js/97.ca9bf771.js"><link rel="prefetch" href="/assets/js/98.5e5c3610.js"><link rel="prefetch" href="/assets/js/99.6781be8d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.815e519c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">二求</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/article/" class="nav-link">博客文章</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">前端算法</a></div><div class="nav-item"><a href="/sourceCode/" class="nav-link">源码释界</a></div><div class="nav-item"><a href="/learnRecord/" class="nav-link">学习笔记</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">前端知识体系</a></div><div class="nav-item"><a href="/weekRead/" class="nav-link">每周阅读</a></div><div class="nav-item"><a href="https://github.com/Rashomon511" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/article/" class="nav-link">博客文章</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">前端算法</a></div><div class="nav-item"><a href="/sourceCode/" class="nav-link">源码释界</a></div><div class="nav-item"><a href="/learnRecord/" class="nav-link">学习笔记</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">前端知识体系</a></div><div class="nav-item"><a href="/weekRead/" class="nav-link">每周阅读</a></div><div class="nav-item"><a href="https://github.com/Rashomon511" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/interviewQuestions/Javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/interviewQuestions/Javascript手写.html" class="sidebar-link">JavaScript手写</a></li><li><a href="/interviewQuestions/Css.html" class="sidebar-link">CSS</a></li><li><a href="/interviewQuestions/Html.html" class="sidebar-link">HTML</a></li><li><a href="/interviewQuestions/浏览器相关.html" class="sidebar-link">浏览器相关</a></li><li><a href="/interviewQuestions/计算机网络.html" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#计算机网络" class="sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#tcp三次握手和四次挥手" class="sidebar-link">TCP三次握手和四次挥手</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#" class="sidebar-link"></a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#tcp和udp的区别" class="sidebar-link">TCP和UDP的区别</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#http与-https-握手过程" class="sidebar-link">HTTP与 HTTPS 握手过程</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#http的状态码请求方式，以及http-head（http头）" class="sidebar-link">http的状态码请求方式，以及HTTP HEAD（HTTP头）</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#http缓存机制" class="sidebar-link">HTTP缓存机制</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#http缓存基本概念" class="sidebar-link">Http缓存基本概念</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#与缓存相关的首部字段" class="sidebar-link">与缓存相关的首部字段</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#首次请求规则" class="sidebar-link">首次请求规则</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#缓存的类型" class="sidebar-link">缓存的类型</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#强制缓存" class="sidebar-link">强制缓存</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#协商缓存" class="sidebar-link">协商缓存</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#不能缓存的请求" class="sidebar-link">不能缓存的请求</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#缓存的优先级" class="sidebar-link">缓存的优先级</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#https的工作原理" class="sidebar-link">HTTPS的工作原理</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#https对称加密和非对称加密" class="sidebar-link">https对称加密和非对称加密</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#https-中间人攻击" class="sidebar-link">HTTPS 中间人攻击</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#劫持https的请求的思路" class="sidebar-link">劫持https的请求的思路</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#http2的多路复用" class="sidebar-link">http2的多路复用</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#websocket" class="sidebar-link">Websocket</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/计算机网络.html#cookie-隔离" class="sidebar-link">Cookie 隔离</a></li></ul></li></ul></li><li><a href="/interviewQuestions/前端框架.html" class="sidebar-link">前端框架</a></li><li><a href="/interviewQuestions/前端工程.html" class="sidebar-link">前端工程</a></li><li><a href="/interviewQuestions/安全与性能.html" class="sidebar-link">安全与性能</a></li><li><a href="/interviewQuestions/Node.html" class="sidebar-link">Node</a></li><li><a href="/interviewQuestions/版本控制.html" class="sidebar-link">版本控制</a></li><li><a href="/interviewQuestions/测试相关.html" class="sidebar-link">测试相关</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="计算机网络"><a href="#计算机网络" aria-hidden="true" class="header-anchor">#</a> 计算机网络</h2> <p><a name="Bm1Ai"></a></p> <h3 id="tcp三次握手和四次挥手"><a href="#tcp三次握手和四次挥手" aria-hidden="true" class="header-anchor">#</a> TCP三次握手和四次挥手</h3> <ul><li>三次握手：</li></ul> <p>TCP的连接建立是一个三次握手过程，目的是为了通信双方确认开始序号<br><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1567479861436-9abb06fe-521c-4b80-9cb3-7dc23ad381a4.png#align=left&amp;display=inline&amp;height=317&amp;name=image.png&amp;originHeight=634&amp;originWidth=1080&amp;size=225998&amp;status=done&amp;width=540" alt="image.png"></p> <blockquote><ul><li>连接开始时，连接建立方(Client)发送SYN包，并包含了自己的初始序号a；</li> <li>连接接受方(Server)收到SYN包以后会回复一个SYN包，其中包含了对上一个a包的回应信息ACK，回应的序号为下一个希望收到包的序号，即a＋1，然后还包含</li> <li>连接建立方(Client)收到回应的SYN包以后，回复一个ACK包做响应，其中包含了下一个希望收到包的序号即b＋1</li></ul></blockquote> <ul><li>四次挥手</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1567479872948-59a4f9d2-d057-4109-ab34-66e93a6db232.png#align=left&amp;display=inline&amp;height=365&amp;name=image.png&amp;originHeight=730&amp;originWidth=1080&amp;size=295524&amp;status=done&amp;width=540" alt="image.png"></p> <blockquote><ul><li>首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭</li> <li>当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</li> <li>同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN</li> <li>客户必须发回一个确认，并将确认序号设置为收到序号加1</li></ul></blockquote> <p>如果两端把数据都发完了后均只发送一次包告诉对方数据完了，而不发送给对方确认包可以吗？我理解是可以的，但是为了保证发的第一次结束确认包能得到对方回复确实收到了而不是丢失，所以各自要多一次确认包，如果丢失了回传的确认包，则发起的一方不管是过去时候丢了还是回来的时候丢了都会重新发起确认，从而耗费资源。
<a name="W4ESJ"></a></p> <h3 id=""><a href="#" aria-hidden="true" class="header-anchor">#</a></h3> <p><a name="qV10f"></a></p> <h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" aria-hidden="true" class="header-anchor">#</a> TCP和UDP的区别</h3> <p>（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。<br>（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。<br>（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。<br>（4）TCP只能是1对1的，UDP支持1对1,1对多。<br>（5）TCP的首部较大为20字节，而UDP只有8字节。<br>（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。<br><strong>socket、tcp、udp、http 的认识及区别</strong><br>一、先来一个讲TCP、UDP和HTTP关系的<br>1、TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。<br>在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。<br>在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。<br>因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。<br>2、HTTP协议是建立在请求/响应模型上的。<br>首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，<br>请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。<br>服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。<br>HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，<br>因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。<br>一次TCP链接的建立将需要3次握手。<br>另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。<br>每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此HTTP/1.1提出了可持续链接的实现方法。<br>HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。<br>3、结论：<br>虽然HTTP本身是一个协议，但其最终还是基于TCP的。不过，目前，有人正在研究基于TCP+UDP混合的HTTP协议。<br>Socket是什么呢？Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，<br>Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，<br>对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>HTTP、TCP、UDP、Socket <wbr> <wbr> <wbr>(转)<br><strong>二、TCP、UDP、HTTP、SOCKET之间的区别</strong><br>TCP和UDP：传输层协议；<br>HTTP：应用层协议；<br>SOCKET：TCP/IP网络的API。<br>TCP/IP代表传输控制协议/网际协议，指的是一系列协议。<br>TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。<br>TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。<br>TCP和UDP是FTP、HTTP和SMTP之类使用的传输层协议。<br>虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。<br>这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。<br>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。<br>客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。<br>记住，需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。<br>Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。<br><strong>三、socket、tcp、udp、http 的认识及区别</strong><br>网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br>IP 协议对应于网络层，TCP协议对应于传输层，HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对TCP/IP协议的封装和应用。<br>可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据<br>socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），<br>通过Socket，我们才能使用TCP/IP协议。<br>实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。<br>所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，<br>从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等<br>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，<br>而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口<br>TCP连接的三次握手：<br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。  <br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据<br>断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”<br>TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，<br>但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性；<br>而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，<br>发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议<br>也正由于上面的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。<br>所以采用TCP传输协议的MSN比采用UDP的QQ传输文件慢，<br>但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，<br>比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，<br>即使是这样，UDP因为在底层协议的封装上没有采用类似 TCP的“三次握手”而实现了TCP所无法达到的传输效率。</p> <p><a name="tbE4n"></a></p> <h3 id="http与-https-握手过程"><a href="#http与-https-握手过程" aria-hidden="true" class="header-anchor">#</a> HTTP与 HTTPS 握手过程</h3> <p><strong>HTTP 握手过程</strong><br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br><strong>HTTPS 握手过程</strong><br>1.建立服务器443端口连接<br>2.SSL握手：随机数，证书，密钥，加密算法<br>3.发送加密请求<br>4.发送加密响应<br>5.关闭SSL<br>6.关闭TCP<br>1.客户端发起HTTPS请求<br>2.服务端的配置<br>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。<br>3.传送证书<br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。<br>4.客户端解析证书<br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。<br>5.传送加密信息<br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。<br>6.服务段解密信息<br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。<br>7.传输加密后的信息<br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。<br>8.客户端解密信息<br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。<br>PS: 整个握手过程第三方即使监听到了数据，也束手无策。<br><strong>https握手时客户端如何验证证书的合法性</strong><br>客户端会有一个有效证书串，一般的浏览器都会内置很多常见服务器的这个证书，特殊的服务器就需要前期通过手工将证书添加到客户端。证明对方是否持有证书的对应的私钥,客户端通过比对来确认证书的有效性<br><strong>为什么HTTPS是安全的？</strong><br>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。<br>HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256<br>注意https加密是在传输层<br>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。<br>当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。<br><strong>HTTPS和HTTP的区别</strong></p> <ol><li>https协议需要到ca申请证书或自制证书。<br></li> <li>http的信息是明文传输，https则是具有安全性的ssl加密。<br></li> <li>http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。<br></li> <li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol> <p><a name="89IHk"></a></p> <h3 id="http的状态码请求方式，以及http-head（http头）"><a href="#http的状态码请求方式，以及http-head（http头）" aria-hidden="true" class="header-anchor">#</a> http的状态码请求方式，以及HTTP HEAD（HTTP头）</h3> <p><strong>HTTP Method 请求方法</strong><br>在requestline里面的方法部分，表示HTTP的操作类型，常见的几种请求方法如下：</p> <blockquote><ul><li>GET：浏览器通过地址访问页面均属于get请求</li> <li>POST：常见的表单提交</li> <li>HEAD ：跟get类似，区别在于只返回请求头</li> <li>PUT：表示添加资源</li> <li>DELETE：表示删除资源</li> <li>CONNECT： 多用于HTTPS和WebSocket</li> <li>OPTIONS</li> <li>TRACE</li></ul></blockquote> <p><strong>HTTP Status code状态码</strong><br>常见的状态码有以下几种：</p> <blockquote><ul><li>1xx：临时回应</li> <li>2xx：请求成功，如200</li> <li>3xx：请求目标有变化，如302和301表示临时和永久重定向，304表示客户端没有更新内容</li> <li>4xx;请求错误，如403无权限，404访问的资源不存在</li> <li>5xx：服务端错误，如500服务端错误，503服务端暂时错误等</li> <li>1XX：信息状态码</li> <li>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li> <li>2XX：成功状态码</li> <li>200 OK 正常返回信息</li> <li>201 Created 请求成功并且服务器创建了新的资源</li> <li>202 Accepted 服务器已接受请求，但尚未处理</li> <li>3XX：重定向</li> <li>301 Moved Permanently 请求的网页已永久移动到新位置。</li> <li>302 Found 临时性重定向。</li> <li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li> <li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li> <li>4XX：客户端错误</li> <li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li> <li>401 Unauthorized 请求未授权。</li> <li>403 Forbidden 禁止访问。</li> <li>404 Not Found 找不到如何与 URI 相匹配的资源。</li> <li>5XX: 服务器错误</li> <li>500 Internal Server Error 最常见的服务器端错误。</li> <li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul></blockquote> <p>在前端开发中，最熟悉的系列无非是大家都喜欢的200请求成功的标志，在面试中，问得较多的是304缓存问题和301、302重定向的问题。
<a name="mCsKn"></a></p> <h3 id="http缓存机制"><a href="#http缓存机制" aria-hidden="true" class="header-anchor">#</a> HTTP缓存机制</h3> <p>Http 缓存机制作为 web 性能优化的重要手段，对从事 Web 开发的小伙伴们来说是必须要掌握的知识，要想彻底搞懂HTTP缓存机制<br>那就需从HTTP缓存基本概念说起。</p> <p><a name="ztFvA"></a></p> <h3 id="http缓存基本概念"><a href="#http缓存基本概念" aria-hidden="true" class="header-anchor">#</a> Http缓存基本概念</h3> <p><strong>Http报文</strong><br>在浏览器和服务器进行Http通信时发送的数据即为Http报文，其中分为两部分：<br>1.header - 报文的首部或头部，其中保存着各类请求的属性字段，关于Http的缓存相关规则信息均保存在header中<br>2.body - 请求体部分，Http请求真正传输的主体部分
<a name="zS9iC"></a></p> <h3 id="与缓存相关的首部字段"><a href="#与缓存相关的首部字段" aria-hidden="true" class="header-anchor">#</a> 与缓存相关的首部字段</h3> <p>1.通用首部字段<br><a href="https://user-images.githubusercontent.com/21194931/56130129-a8ab5c80-5fb6-11e9-8294-2da41892ccdf.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914296650-15e2e629-5ab8-4b66-92fc-a60479f267c0.png#align=left&amp;display=inline&amp;height=82&amp;originHeight=82&amp;originWidth=649&amp;size=0&amp;status=done&amp;width=649" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>2.请求首部字段<br><a href="https://user-images.githubusercontent.com/21194931/56130136-ad701080-5fb6-11e9-8308-33dd69394269.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914299049-5400bced-9ef9-43ba-a706-c2eef9d5e6bd.png#align=left&amp;display=inline&amp;height=132&amp;originHeight=132&amp;originWidth=649&amp;size=0&amp;status=done&amp;width=649" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>3.响应首部字段<br><a href="https://user-images.githubusercontent.com/21194931/56130143-b365f180-5fb6-11e9-9d34-22c3e41c18ba.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914295854-7429dea4-14b3-407c-b718-b102f952f61f.png#align=left&amp;display=inline&amp;height=57&amp;originHeight=57&amp;originWidth=648&amp;size=0&amp;status=done&amp;width=648" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>4.实体首部字段<br><a href="https://user-images.githubusercontent.com/21194931/56130159-bd87f000-5fb6-11e9-81ac-98e70067185e.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914297961-7d544c73-fbc3-4f70-a2b5-a241c8bc2c01.png#align=left&amp;display=inline&amp;height=82&amp;originHeight=82&amp;originWidth=648&amp;size=0&amp;status=done&amp;width=648" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a name="iCxh1"></a></p> <h3 id="首次请求规则"><a href="#首次请求规则" aria-hidden="true" class="header-anchor">#</a> 首次请求规则</h3> <p>Http缓存主要涉及三个角色：一是浏览器，二是浏览器的缓存数据库，三是服务器。当浏览器端向服务器发出第一次请求时：<br><a href="https://user-images.githubusercontent.com/21194931/56130179-caa4df00-5fb6-11e9-867f-a609f5a23982.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914299016-af47c2ef-0653-482b-99d0-8bf2815d4828.png#align=left&amp;display=inline&amp;height=734&amp;originHeight=734&amp;originWidth=1166&amp;size=0&amp;status=done&amp;width=1166" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a name="hi0WY"></a></p> <h3 id="缓存的类型"><a href="#缓存的类型" aria-hidden="true" class="header-anchor">#</a> 缓存的类型</h3> <blockquote><p>缓存的类型主要分为两种：强制缓存和协商缓存</p></blockquote> <p>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。
<a name="410b0"></a></p> <h3 id="强制缓存"><a href="#强制缓存" aria-hidden="true" class="header-anchor">#</a> 强制缓存</h3> <p>强缓存基本原理是：所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据。当缓存未过期时基本流程如下<br>而控制强缓存过期时间的主要有两个规则字段：</p> <ol><li>Expire 其指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的。但是它本身是一个HTTP1.0标准下的字段，所以如果请求中还有一个置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么 Expires 头就会被忽略。</li> <li>Cache-Control通用消息头用于在http 请求和响应中通过指定指令来实现缓存机制。其常用的几个取值有：</li></ol> <p>private：客户端可以缓存<br>public：客户端和代理服务器都可以缓存<br>max-age=xxx：缓存的内容将在xxx 秒后失效<br>s-max-age=xxx：同s-max-age，但仅适用于共享缓存(比如各个代理)，并且私有缓存中忽略。<br>no-cache：需要使用协商缓存来验证缓存数据<br>no-store：所有内容都不会缓存，强缓存和协商缓存都不会触发<br>must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。<br>例如:<br><a href="https://user-images.githubusercontent.com/21194931/56130194-d2648380-5fb6-11e9-902c-eb23b7220445.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914297224-0d625dc4-3b30-4c2a-b146-d52d07638def.png#align=left&amp;display=inline&amp;height=668&amp;originHeight=668&amp;originWidth=1736&amp;size=0&amp;status=done&amp;width=1736" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>其中的Cache-Control字段中即标识了缓存可以被客户端和代理服务器缓存，并且缓存的时间为315…秒(365天)后失效，我们在执行这一请求时在其缓存过期时间之内，所以直接命中并从磁盘中读取，不需要与服务器交互。
<a name="IWClW"></a></p> <h3 id="协商缓存"><a href="#协商缓存" aria-hidden="true" class="header-anchor">#</a> 协商缓存</h3> <p>协商存基本原理是：浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。<br>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据<br><strong>Last-Modified/If-Modified-Since规则</strong> <a name="TQJ7d"></a></p> <h5 id="last-modified："><a href="#last-modified：" aria-hidden="true" class="header-anchor">#</a> Last-Modified：</h5> <p>服务器在响应请求时，告诉浏览器资源的最后修改时间。
<a name="0994X"></a></p> <h5 id="if-modified-since："><a href="#if-modified-since：" aria-hidden="true" class="header-anchor">#</a> If-Modified-Since：</h5> <p>再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。<br>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；<br>若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。<br><strong>Etag/If-None-Match规则（优先级高于Last-Modified/If-Modified-Since）</strong> <a name="xsePD"></a></p> <h5 id="etag："><a href="#etag：" aria-hidden="true" class="header-anchor">#</a> Etag：</h5> <p>服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.
<a name="Anf4d"></a></p> <h5 id="if-none-match："><a href="#if-none-match：" aria-hidden="true" class="header-anchor">#</a> If-None-Match：</h5> <p>再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。<br>服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，<br>不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；<br>相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。<br>浏览器第二次请求过程：<br><a href="https://user-images.githubusercontent.com/21194931/56130204-d8f2fb00-5fb6-11e9-9cf7-f4f03a3c87de.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914304275-7d128cb2-64da-40e2-9600-d692151f8237.png#align=left&amp;display=inline&amp;height=531&amp;originHeight=531&amp;originWidth=556&amp;size=0&amp;status=done&amp;width=556" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a name="1zSyN"></a></p> <h3 id="不能缓存的请求"><a href="#不能缓存的请求" aria-hidden="true" class="header-anchor">#</a> 不能缓存的请求</h3> <p>1.不能被缓存的请求HTTP 信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0 等告诉浏览器不用缓存的请求<br>2.需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的<br>3.经过HTTPS安全加密的请求（有人也经过测试发现，ie 其实在头部加入 Cache-Control：max-age 信息，firefox 在头部加入 Cache-Control:Public 之后，能够对HTTPS的资源进行缓存）<br>4.HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存<br>5.目前浏览器的实现是不会对POST请求的响应做缓存的（从语义上来说也不应该），并且规范中也规定了返回状态码不允许是304。不过这并不表示POST的响应不能被缓存，根据RFC 7231 - Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content中描述的，如果在POST请求对应的响应中包含Freshness相关信息的话，这次响应也是可以被缓存，具体可以参考上面的那个链接
<a name="g1PPs"></a></p> <h3 id="缓存的优先级"><a href="#缓存的优先级" aria-hidden="true" class="header-anchor">#</a> 缓存的优先级</h3> <blockquote><p>Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</p></blockquote> <p><a name="stG9Q"></a></p> <h3 id="https的工作原理"><a href="#https的工作原理" aria-hidden="true" class="header-anchor">#</a> HTTPS的工作原理</h3> <p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p> <ul><li>浏览器将自己支持的一套加密规则发送给网站。<br></li> <li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。<br></li> <li>获得网站证书之后浏览器要做以下工作：<br></li></ul> <p>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</p> <ul><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。<br></li> <li>4.网站接收浏览器发来的数据之后要做以下的操作：<br></li></ul> <p>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>b) 使用密码加密一段握手消息，发送给浏览器。</p> <ul><li>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li></ul> <p><a name="4dMIW"></a></p> <h3 id="https对称加密和非对称加密"><a href="#https对称加密和非对称加密" aria-hidden="true" class="header-anchor">#</a> https对称加密和非对称加密</h3> <p><strong>对称加密：</strong><br>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。<br><strong>非对称加密：</strong><br>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。<br>在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。<br>非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。<br><strong>几个名词要理清</strong><br>RSA：非对称加密<br>AES：对称加密 生成一个随机字符串key 只有客户端和服务端有 他们两个通过这个key对数据加密和传输跟解密 这一个统称对称加密<br>CA：权威认证机构 服务器在建站的时候 去CA认证机构认证 得到对应的数字签名 相当于身份证号 客户端每次安装浏览器的时候 都会下载最新的CA列表 这个列表有对应的数字签名和服务器IP一一对应的列表 这就是为什么我们自己搭建的localhost没法发https的原因 因为没法进行CA认证<br>数字证书：包含了数字签名跟RSA公钥<br>数字签名：保证数字证书一定是服务器传给客户端的 相当于服务器的身份证ID<br>对称密钥： 对数据进行加密的key<br>非对称密钥： （k1， k2） k1加密的数据 只有k2能解开 k1位非对称公钥 k2为非对称私钥<br>非对称公钥：RSA公钥 k1加密的数据 只有k2能解开<br>非对称私钥：RSA私钥 k1加密的数据 只有k2能解开</p> <p><a name="ipzKa"></a></p> <h3 id="https-中间人攻击"><a href="#https-中间人攻击" aria-hidden="true" class="header-anchor">#</a> HTTPS 中间人攻击</h3> <p>中间人攻击，即所谓的Man-in-the-middle attack(MITM)，顾名思义，就是攻击者插入到原本直接通信的双方，让双方以为还在直接跟对方通讯，但实际上双方的通信对方已变成了中间人，信息已经是被中间人获取或篡改<br><strong>1.SSL证书欺骗攻击</strong><br>此类攻击较为简单常见。首先通过ARP欺骗、DNS劫持甚至网关劫持等等，将客户端的访问重定向到攻击者的机器，让客户端机器与攻击者机器建立HTTPS连接（使用伪造证书），而攻击者机器再跟服务端连接。这样用户在客户端看到的是相同域名的网站，但浏览器会提示证书不可信，用户不点击继续浏览就能避免被劫持的。所以这是最简单的攻击方式，也是最容易识别的攻击方式。<br><a href="https://user-images.githubusercontent.com/21194931/59647024-230d7e00-91ac-11e9-8da8-ed7748dff5ba.png" target="_blank" rel="noopener noreferrer"><img src="https://cdn.nlark.com/yuque/0/2019/png/218767/1566914668301-7f7e31fd-a9b5-4ca6-99aa-37f37a7e1099.png#align=left&amp;display=inline&amp;height=233&amp;originHeight=233&amp;originWidth=633&amp;size=0&amp;status=done&amp;width=633" alt=""><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>钓鱼类攻击，App直接调用系统API创建的HTTPS连接（NSURLConnection）一般不会受到影响，只使用默认的系统校验，只要系统之前没有信任相关的伪造证书，校验就直接失败，不会SSL握手成功；但如果是使用WebView浏览网页，需要在UIWebView中加入较强的授权校验，禁止用户在校验失败的情况下继续访问。<br><strong>2.SSL剥离攻击（SSLStrip）</strong><br>SSL剥离，即将HTTPS连接降级到HTTP连接。假如客户端直接访问HTTPS的URL，攻击者是没办法直接进行降级的，因为HTTPS与HTTP虽然都是TCP连接，但HTTPS在传输HTTP数据之前，需要在进行了SSL握手，并协商传输密钥用来后续的加密传输；假如客户端与攻击者进行SSL握手，而攻击者无法提供可信任的证书来让客户端验证通过进行连接，所以客户端的系统会判断为SSL握手失败，断开连接。<br>该攻击方式主要是利用用户并不会每次都直接在浏览器上输入<a href="https://xxx.xxx.com%E6%9D%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%EF%BC%8C%E6%88%96%E8%80%85%E6%9C%89%E4%BA%9B%E7%BD%91%E7%AB%99%E5%B9%B6%E9%9D%9E%E5%85%A8%E7%BD%91https%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%AA%E5%9C%A8%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%97%B6%E6%89%8D%E4%BD%BF%E7%94%A8https%E7%9A%84%E6%BC%8F%E6%B4%9E%E3%80%82%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E8%80%85%E5%9C%A8%E5%8A%AB%E6%8C%81%E4%BA%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84http%E4%BC%9A%E8%AF%9D%E5%90%8E%EF%BC%8C%E5%B0%86http%E9%A1%B5%E9%9D%A2%E9%87%8C%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84https//%E8%B6%85%E9%93%BE%E6%8E%A5%E9%83%BD%E6%8D%A2%E6%88%90http://%EF%BC%8C%E7%94%A8%E6%88%B7%E5%9C%A8%E7%82%B9%E5%87%BB%E7%9B%B8%E5%BA%94%E7%9A%84%E9%93%BE%E6%8E%A5%E6%97%B6%EF%BC%8C%E6%98%AF%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%9B%E8%BF%99%E6%A0%B7%EF%BC%8C%E5%B0%B1%E7%AE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E7%9B%B8%E5%BA%94%E7%9A%84URL%E5%8F%AA%E6%94%AF%E6%8C%81HTTPS%E9%93%BE%E6%8E%A5%EF%BC%8C%E4%BD%86%E4%B8%AD%E9%97%B4%E4%BA%BA%E4%B8%80%E6%A0%B7%E5%8F%AF%E4%BB%A5%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BB%BA%E7%AB%8BHTTPS%E8%BF%9E%E6%8E%A5%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8F%91%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81%E3%80%82" target="_blank" rel="noopener noreferrer">https://xxx.xxx.com来访问网站，或者有些网站并非全网HTTPS，而是只在需要进行敏感数据传输时才使用HTTPS的漏洞。中间人攻击者在劫持了客户端与服务端的HTTP会话后，将HTTP页面里面所有的https://超链接都换成http://，用户在点击相应的链接时，是使用HTTP协议来进行访问；这样，就算服务器对相应的URL只支持HTTPS链接，但中间人一样可以和服务建立HTTPS连接之后，将数据使用HTTP协议转发给客户端，实现会话劫持。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>这种攻击手段更让人难以提防，因为它使用HTTP，不会让浏览器出现HTTPS证书不可信的警告，而且用户很少会去看浏览器上的URL是<a href="https://xn--http-zi0i364s//%E3%80%82%E7%89%B9%E5%88%AB%E6%98%AFApp%E7%9A%84WebView%E4%B8%AD%EF%BC%8C%E5%BA%94%E7%94%A8%E4%B8%80%E8%88%AC%E4%BC%9A%E6%8A%8AURL%E9%9A%90%E8%97%8F%E6%8E%89%EF%BC%8C%E7%94%A8%E6%88%B7%E6%A0%B9%E6%9C%AC%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E6%9F%A5%E7%9C%8B%E5%88%B0URL%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E3%80%82" target="_blank" rel="noopener noreferrer">https://还是http://。特别是App的WebView中，应用一般会把URL隐藏掉，用户根本无法直接查看到URL出现异常。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>该种攻击方式同样无法劫持App内的HTTPS连接会话，因为App中传入请求的URL参数是固定带有<a href="https://%E7%9A%84%EF%BC%9B%E4%BD%86%E5%9C%A8webview%E4%B8%AD%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E5%90%8C%E6%A0%B7%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%9C%A8%E9%9D%9E%E5%85%A8%E7%BD%91https%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%AF%B9webview%E4%B8%AD%E6%89%93%E5%BC%80%E7%9A%84url%E5%81%9A%E6%A3%80%E6%9F%A5%EF%BC%8C%E6%A3%80%E6%9F%A5%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8https//%E7%9A%84URL%E6%98%AF%E5%90%A6%E8%A2%AB%E7%AF%A1%E6%94%B9%E4%B8%BAhttp://%EF%BC%9B%E4%B9%9F%E5%BB%BA%E8%AE%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9C%A8%E9%85%8D%E7%BD%AEHTTPS%E6%9C%8D%E5%8A%A1%E6%97%B6%EF%BC%8C%E5%8A%A0%E4%B8%8A%E2%80%9CHTTP" target="_blank" rel="noopener noreferrer">https://的；但在WebView中打开网页同样需要注意，在非全网HTTPS的网站，建议对WebView中打开的URL做检查，检查应该使用https://的URL是否被篡改为http://；也建议服务端在配置HTTPS服务时，加上“HTTP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> Strict Transport Security”配置项。<br><strong>防范HTTPS中间人攻击</strong></p> <ul><li>不要随意连入公共场合内的WiFi，或者使用未知代理服务器</li> <li>不要安装不可信或突然出现的描述文件，信任伪造的证书；（如某12306，在正规渠道下载系统以及浏览器）</li> <li>App内部需对服务器证书进行单独的对比校验，确认证书不是伪造的；
<ul><li>查看证书是否过期</li> <li>服务器证书上的域名是否和服务器的实际域名相匹配</li> <li>校验证书链</li> <li>打包证书校验</li></ul></li></ul> <p><a name="yswKR"></a></p> <h3 id="劫持https的请求的思路"><a href="#劫持https的请求的思路" aria-hidden="true" class="header-anchor">#</a> 劫持https的请求的思路</h3> <p>模拟中间人攻击，以百度为例<br>先用OpenSSL查看下证书，直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>openssl s_client <span class="token operator">-</span>connect www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">443</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>用sslcan识别ssl配置错误，过期协议，过时cipher suite和hash算法</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>sslscan <span class="token operator">-</span>tlsall www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">443</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>分析证书详细数据</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>sslscan <span class="token operator">-</span>show<span class="token operator">-</span>certificate <span class="token operator">--</span>no<span class="token operator">-</span>ciphersuites www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">443</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>生成一个证书</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>openssl req <span class="token operator">-</span><span class="token keyword">new</span> <span class="token operator">-</span>x509 <span class="token operator">-</span>days <span class="token number">1096</span> <span class="token operator">-</span>key ca<span class="token punctuation">.</span>key <span class="token operator">-</span>out ca<span class="token punctuation">.</span>crt
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>开启路由功能</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>sysctl <span class="token operator">-</span>w net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>ip_forward<span class="token operator">=</span><span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>写转发规则，将80、443端口进行转发给8080和8443端口</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>iptables <span class="token operator">-</span>t nat <span class="token operator">-</span><span class="token constant">A</span> <span class="token constant">PREROUTING</span> <span class="token operator">-</span>p tcp <span class="token operator">--</span>dport <span class="token number">80</span> <span class="token operator">-</span>j <span class="token constant">REDIRECT</span> <span class="token operator">--</span>to<span class="token operator">-</span>ports <span class="token number">8080</span>
   iptables <span class="token operator">-</span>t nat <span class="token operator">-</span><span class="token constant">A</span> <span class="token constant">PREROUTING</span> <span class="token operator">-</span>p tcp <span class="token operator">--</span>dport <span class="token number">443</span> <span class="token operator">-</span>j <span class="token constant">REDIRECT</span> <span class="token operator">--</span>to<span class="token operator">-</span>ports <span class="token number">8443</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>最后使用arpspoof进行arp欺骗</p> <p><a name="FwOtE"></a></p> <h3 id="http2的多路复用"><a href="#http2的多路复用" aria-hidden="true" class="header-anchor">#</a> http2的多路复用</h3> <p>HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。<br>多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。<br>HTTP2中<br>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。<br>单个连接上可以并行交错的请求和响应，之间互不干扰<br>**影响 JavaScript 应用程序打包<br>**我们目前把多个文件打包的做法让浏览器很难高效地缓存代码：在一个模块里改动一行代码也需要重新下载整个打包后的文件。随着HTTP/2的多路复用让请求变得不那么昂贵，我们可以选择把代码分割到小模块里，以更好地利用缓存，确保我们的应用高效地利用用户的带宽。<br>。随着JavaScript社区正在朝更小的、更专一的模块方向发展，给客户端提供未打包的文件也不太理想。除此之外，把文件合并在一起可以更好地压缩，节省带宽。</p> <p><a name="kkCSe"></a></p> <h3 id="websocket"><a href="#websocket" aria-hidden="true" class="header-anchor">#</a> Websocket</h3> <p>Websocket 是一个 持久化的协议， 基于 http ， 服务端可以 主动 push<br>兼容：</p> <ul><li>FLASH Socket</li> <li>长轮询： 定时发送 ajax</li> <li>long poll： 发送 --&gt; 有消息时再 response</li></ul> <p>用法：</p> <ul><li>new WebSocket(url)</li> <li>ws.onerror = fn</li> <li>ws.onclose = fn</li> <li>ws.onopen = fn</li> <li>ws.onmessage = fn</li> <li>ws.send()</li></ul> <p><a name="K19nf"></a></p> <h3 id="cookie-隔离"><a href="#cookie-隔离" aria-hidden="true" class="header-anchor">#</a> Cookie 隔离</h3> <p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，<br>所以不如隔离开。<br>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，<br>这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。<br>同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，<br>提高了webserver的http请求的解析速度。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间: </span> <span class="time">10/8/2019, 7:41:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/interviewQuestions/浏览器相关.html" class="prev">
          浏览器相关
        </a></span> <span class="next"><a href="/interviewQuestions/前端框架.html">
          前端框架
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.20d1c662.js" defer></script><script src="/assets/js/2.b4f839d5.js" defer></script><script src="/assets/js/186.9e3fd258.js" defer></script>
  </body>
</html>
