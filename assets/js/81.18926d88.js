(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{358:function(a,t,r){"use strict";r.r(t);var e=r(0),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"数据结构与算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据结构与算法简介")]),a._v(" "),r("p",[r("a",{attrs:{name:"8QRdM"}})]),a._v(" "),r("h3",{attrs:{id:"常见的数据结构与算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见的数据结构与算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 常见的数据结构与算法")]),a._v(" "),r("p",[a._v("一.数组结构：数组、链表、队列、栈、散列表、二叉树、堆、跳表、图、Trie树"),r("br"),a._v("二.算法思想：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配")]),a._v(" "),r("p",[r("a",{attrs:{name:"SLIWr"}})]),a._v(" "),r("h3",{attrs:{id:"复杂度分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 复杂度分析")]),a._v(" "),r("p",[r("a",{attrs:{name:"WSQDs"}})]),a._v(" "),r("h4",{attrs:{id:"时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 时间复杂度")]),a._v(" "),r("p",[a._v("全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。"),r("br"),r("strong",[a._v("三点原则：")]),a._v(" "),r("a",{attrs:{name:"9AGv4"}})]),a._v(" "),r("h6",{attrs:{id:"_1-只关注循环执行次数最多的一段代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-只关注循环执行次数最多的一段代码","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 只关注循环执行次数最多的一段代码")]),a._v(" "),r("p",[a._v("大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。\n"),r("a",{attrs:{name:"aUMXT"}})]),a._v(" "),r("h6",{attrs:{id:"_2-加法法则：总复杂度等于量级最大的那段代码的复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-加法法则：总复杂度等于量级最大的那段代码的复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度")]),a._v(" "),r("p",[a._v("代码中有多段循环代码，选取量级最大的那段为标准。\n"),r("a",{attrs:{name:"20cbQ"}})]),a._v(" "),r("h6",{attrs:{id:"_3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积","aria-hidden":"true"}},[a._v("#")]),a._v(" 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积`")]),a._v(" "),r("p",[a._v("与加法法则不同，有嵌套的情况，复杂度应为乘积。"),r("br"),a._v("常见的时间复杂度有以下几种："),r("br"),a._v("1）常量阶："),r("code",[a._v("O(1)")]),r("br"),a._v("2）对数阶："),r("code",[a._v("O(logn)")]),r("br"),a._v("3）线性阶："),r("code",[a._v("O(n)")]),r("br"),a._v("4）线性对数阶："),r("code",[a._v("O(nlogn)")]),r("br"),a._v("5）平方阶："),r("code",[a._v("O(n ^ 2)")]),r("br"),a._v("6）指数阶："),r("code",[a._v("O(2 ^ n)")]),r("br"),a._v("7）阶乘阶："),r("code",[a._v("O(n!)")]),r("br"),a._v("其中，1）-5）为多项式量级；6）、7）为非多项式量级，所对应的算法问题被称为非确定多项式问题（NP 问题，Non-Deterministic Polynomial）。\n"),r("a",{attrs:{name:"aq3dt"}})]),a._v(" "),r("h4",{attrs:{id:"空间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 空间复杂度")]),a._v(" "),r("p",[a._v("全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。"),r("br"),a._v("空间复杂度较时间复杂度来说要简单得多，只看要分析的代码分配了占用多少空间的变量即可，常见的空间复杂度就是 O(1)、O(n)、O(n2 )，对数阶的复杂度平时很少见"),r("br"),r("strong",[a._v("大O符号中指定的算法的增长顺序")]),r("br"),r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/218767/1570541395276-4e043ce2-1776-483a-a842-58c460d138f2.png#align=left&display=inline&height=773&name=image.png&originHeight=1546&originWidth=2448&search=&size=234424&status=done&width=1224",alt:"image.png"}}),a._v(" "),r("a",{attrs:{name:"JCcgq"}})]),a._v(" "),r("h3",{attrs:{id:"思维导图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#思维导图","aria-hidden":"true"}},[a._v("#")]),a._v(" 思维导图")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/218767/1570539715706-97e06b02-9b55-4aad-93d6-07a08a70a184.png#align=left&display=inline&height=1669&name=image.png&originHeight=3338&originWidth=1534&search=&size=1074711&status=done&width=767",alt:"image.png"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);